def material;

def hit_record {
    p: point3,
    normal: vec3,
    mat: material*,
    t: flt64,
    front_face: bool
}

@set_face_normal:hit_record(r: ray, outward_normal: vec3): void {
    ## Sets the hit record normal vector.
    ## NOTE: the parameter `outward_normal` is assumed to have unit length.

    me!front_face = dot(r.direction, outward_normal) < 0;
    me!normal = me!front_face ? outward_normal : -outward_normal;
}

def hittable {
    type: int8
}

def sphere;
@hit:sphere(r: ray, ray_t: interval, rec: hit_record*): bool;
@bounding_box:sphere:aabb;

def hittable_list;
@hit:hittable_list(r: ray, ray_t: interval, rec: hit_record*): bool;
@bounding_box:hittable_list:aabb;

def bvh_node;
@hit:bvh_node(r: ray, ray_t: interval, rec: hit_record*): bool;
@bounding_box:bvh_node:aabb;

@hit:hittable(r: ray, ray_t: interval, rec: hit_record*): bool {
    if (me!type == 'S') ret ([sphere*]me)!hit(r, ray_t, rec);
    if (me!type == 'L') ret ([hittable_list*]me)!hit(r, ray_t, rec);
    if (me!type == 'B') ret ([bvh_node*]me)!hit(r, ray_t, rec);
    printf("hit:hittable %c\n", me!type);
    ret false;
}

@bounding_box:hittable:aabb {
    if (me!type == 'S') ret ([sphere*]me)!bounding_box();
    if (me!type == 'L') ret ([hittable_list*]me)!bounding_box();
    if (me!type == 'B') ret ([bvh_node*]me)!bounding_box();
    printf("bounding_box:hittable %c\n", me!type);
    ret aabb();
}
