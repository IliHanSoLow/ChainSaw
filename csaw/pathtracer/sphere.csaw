def sphere {
    type: int8,
    center: point3,
    radius: flt64
}

$sphere(center: point3, radius: flt64) {
    me!type = 'S';
    me!center = center;
    me!radius = fmax(0.0, radius);
}

@hit:sphere(r: ray*, rec: hit_record*): bool {
    oc: vec3 = me!center - r!origin;
    a: flt64 = r!direction.length_squared();
    h: flt64 = dot(r!direction, oc);
    c: flt64 = oc.length_squared() - me!radius * me!radius;

    discriminant: flt64 = h * h - a * c;
    if (discriminant < 0)
        ret false;

    sqrtd: flt64 = sqrt(discriminant);
    inva: flt64 = 1 / a;

    ## Find the nearest root that lies in the acceptable range
    root: flt64 = (h - sqrtd) * inva;
    if (!r!t.surrounds(root)) {
        root = (h + sqrtd) * inva;
        if (!r!t.surrounds(root))
            ret false;
    }

    rec!t = root;
    rec!p = r!at(rec!t);
    outward_normal: vec3 = (rec!p - me!center) / me!radius;
    rec!set_face_normal(r, outward_normal);

    ret true;
}
