def sphere {
    type: int8,
    center: point3,
    radius: flt64,
    mat: material*
} ## size: 1 + 3 * 8 + 8 + 8 = 41

$sphere(center: point3, radius: flt64, mat: material*) {
    me!type = 'S';
    me!center = center;
    me!radius = fmax(0.0, radius);
    me!mat = mat;
}

@hit:sphere(r: ray, rec: hit_record*): bool {
    oc: vec3 = me!center - r.origin;
    a: flt64 = r.direction.length_squared();
    h: flt64 = dot(r.direction, oc);
    c: flt64 = oc.length_squared() - me!radius * me!radius;

    discriminant: flt64 = h * h - a * c;
    if (discriminant < 0)
        ret false;

    sqrtd: flt64 = sqrt(discriminant);
    inva: flt64 = 1 / a;

    ## Find the nearest root that lies in the acceptable range
    root: flt64 = (h - sqrtd) * inva;
    if (!r.t.surrounds(root)) {
        root = (h + sqrtd) * inva;
        if (!r.t.surrounds(root))
            ret false;
    }

    rec!t = root;
    rec!p = r.at(rec!t);
    outward_normal: vec3 = (rec!p - me!center) / me!radius;
    rec!set_face_normal(r, outward_normal);
    rec!mat = me!mat;

    ret true;
}

@dump:sphere = printf("%p: type=%c center=[%f, %f, %f] radius=%f mat=%p\n", me, me!type, me!center.x, me!center.y, me!center.z, me!radius, me!mat);
