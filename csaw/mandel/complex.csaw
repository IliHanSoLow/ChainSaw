def complex {
    real: flt64,
    imaginary: flt64,
}

$complex(real: flt64, imaginary: flt64) {
    me.real = real;
    me.imaginary = imaginary;
}

$complex = complex(0, 0);

@(+=):complex(z: complex): complex {
    me.real += z.real;
    me.imaginary += z.imaginary;
    ret me;
}

@(-=):complex(z: complex): complex {
    me.real -= z.real;
    me.imaginary -= z.imaginary;
    ret me;
}

@(*=):complex(z: complex): complex {
    real:      flt64 = me.real * z.real - me.imaginary * z.imaginary;
    imaginary: flt64 = me.real * z.imaginary + me.imaginary * z.real;
    me.real = real;
    me.imaginary = imaginary;
    ret me;
}

@(/=):complex(z: complex): complex {
    me *= z.conjugate();
    div: flt64 = 1 / pow(z.mod(), 2);
    me.real *= div;
    me.imaginary *= div;
    ret me;
}

@(+)(z1: complex, z2: complex): complex {
    ret complex(z1.real + z2.real, z1.imaginary + z2.imaginary);
}

@(-)(z1: complex, z2: complex): complex {
    ret complex(z1.real - z2.real, z1.imaginary - z2.imaginary);
}

@(*)(z1: complex, z2: complex): complex {
    real:      flt64 = z1.real * z2.real - z1.imaginary * z2.imaginary;
    imaginary: flt64 = z1.real * z2.imaginary + z1.imaginary * z2.real;
    ret complex(real, imaginary);
}

@(/)(z1: complex, z2: complex): complex {
    res: complex = z1 * z2.conjugate();
    div: flt64 = 1 / pow(z2.mod(), 2);
    ret complex(res.real * div, res.imaginary * div);
}

@conjugate:complex:complex {
    ret complex(me.real, -me.imaginary);
}

@mod:complex:flt64 {
    ret sqrt(pow(me.real, 2) + pow(me.imaginary, 2));
}

@square:complex:complex {
    real: flt64 = me.real * me.real - me.imaginary * me.imaginary;
    imaginary: flt64 = 2 * me.real * me.imaginary;
    ret complex(real, imaginary);
}

@tostring:complex(c: complex): int8* {
	ret format("%f %s%fi", c.real, (c.imaginary < 0 ? "" : "+ "), c.imaginary);
}

@exp(z: complex): complex {
    a: flt64 = z.real;
    b: flt64 = z.imaginary;
    r: flt64 = exp(a);
    a = r * cos(b);
    b = r * sin(b);
    ret complex(a, b);
}

@sin(z: complex): complex {
    x: flt64 = exp(z.imaginary);
    x_inv: flt64 = 1 / x;
    r: flt64 = sin(z.real) * (x + x_inv) / 2;
    i: flt64 = cos(z.real) * (x - x_inv) / 2;
    ret complex(r, i);
}

@cos(z: complex): complex {
    x: flt64 = exp(z.imaginary);
    x_inv: flt64 = 1 / x;
    r: flt64 = cos(z.real) * (x + x_inv) / 2;
    i: flt64 = -sin(z.real) * (x - x_inv) / 2;
    ret complex(r, i);
}

@tan(z: complex): complex {
    ret sin(z) / cos(z);
}

@cot(z: complex): complex {
    ret complex(1, 0) / tan(z);
}

@sec(z: complex): complex {
    ret complex(1, 0) / cos(z);
}

@cosec(z: complex): complex {
    ret complex(1, 0) / sin(z);
}

@arg:complex:flt64 {
    ret atan2(me.imaginary, me.real);
}

@inverse:complex:complex {
    ret complex(1, 0) / me;
}

@abs:complex:flt64 {
    ret sqrt(me.real * me.real + me.imaginary * me.imaginary);
}
